"use strict";(self.webpackChunkmypublicsite=self.webpackChunkmypublicsite||[]).push([[138,213],{213:function(e,t,n){n.r(t);n(791);var a=n(184);t.default=function(e){var t,n=e.category,i=e.date,o=e.githuburl,s=e.summary;return t=o?(0,a.jsx)("a",{href:o,target:"_blank",children:"GitHub"}):" - ",(0,a.jsxs)("div",{className:"col-lg-4",children:[(0,a.jsxs)("div",{className:"portfolio-info",children:[(0,a.jsx)("h3",{children:"Information"}),(0,a.jsxs)("ul",{children:[(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Category"}),": ",n]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Publish date"}),": ",i]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Project URL"}),":",t]})]})]}),(0,a.jsxs)("div",{className:"portfolio-description",children:[(0,a.jsx)("h2",{children:"Summary"}),(0,a.jsx)("p",{children:s})]})]})}},138:function(e,t,n){n.r(t),n.d(t,{default:function(){return m}});var a=n(791),i=n(504),o=n(184),s=function(e){var t=e.title;return(0,o.jsx)("section",{id:"breadcrumbs",className:"breadcrumbs",children:(0,o.jsx)("div",{className:"container",children:(0,o.jsxs)("div",{className:"d-flex justify-content-between align-items-center",children:[(0,o.jsx)("h2",{children:t}),(0,o.jsx)("ol",{children:(0,o.jsx)("li",{children:(0,o.jsx)(i.rU,{to:"/",children:"Home"})})})]})})})},r=n(213);function c(e,t){return c=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},c(e,t)}var l=function(e){var t,n;function i(){return e.apply(this,arguments)||this}n=e,(t=i).prototype=Object.create(n.prototype),t.prototype.constructor=t,c(t,n);var o=i.prototype;return o.componentDidMount=function(){this._updateIframeContent()},o.componentDidUpdate=function(e,t){this._updateIframeContent()},o._defineUrl=function(){var e=this.props,t=e.id,n=e.file;return"https://gist.github.com/"+t+".js"+(n?"?file="+n:"")},o._updateIframeContent=function(){var e=this.props,t=e.id,n=e.file,a=this.iframeNode,i=a.document;a.contentDocument?i=a.contentDocument:a.contentWindow&&(i=a.contentWindow.document);var o='<html><head><base target="_parent"><style>*{font-size:12px;}</style></head><body '+("onload=\"parent.document.getElementById('"+(n?"gist-"+t+"-"+n:"gist-"+t)+"').style.height=document.body.scrollHeight + 'px'\"")+">"+('<script type="text/javascript" src="'+this._defineUrl()+'"><\/script>')+"</body></html>";i.open(),i.writeln(o),i.close()},o.render=function(){var e=this,t=this.props,n=t.id,i=t.file;return a.createElement("iframe",{ref:function(t){e.iframeNode=t},width:"100%",frameBorder:0,id:i?"gist-"+n+"-"+i:"gist-"+n})},i}(a.PureComponent),d=l,h=n(779),m=function(){return(0,o.jsxs)(a.Fragment,{children:[(0,o.jsx)(s,{title:"Avoid Relay Commands and prevent CPU usage peaks in WPF(C#)"}),(0,o.jsx)("section",{id:"portfolio-details",className:"portfolio-details",children:(0,o.jsx)("div",{className:"container",children:(0,o.jsxs)("div",{className:"row gy-4",children:[(0,o.jsxs)("div",{className:"col-lg-8",children:[(0,o.jsx)("h2",{children:"Introduction"}),(0,o.jsxs)("p",{children:["When using MVVM pattern in a WPF application we usually create custom ICommand implementations, one of them is known as Relay Command. If you are unfamiliar with commands a good starting point is"," ",(0,o.jsx)("a",{href:"https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/commanding-overview?view=netframeworkdesktop-4.8",target:"_blank",children:"here"}),"."]}),(0,o.jsxs)("p",{children:["I have worked in several WPF applications that had peaks on CPU usage, and profiling the application, using"," ",(0,o.jsx)("a",{href:"https://www.jetbrains.com/profiler/",target:"_blank",children:"dotTrace"}),"\xa0profile for example, we could see several millions of calls to the CanExecute method. This type of commands are spread around the application and have significant impact for long living View Models, like the \u201cRoot\u201d View Model, that could have hundred of commands, for example: in menus, context menus , toolbars and other input controls. In this article I explain why Relay Commands may have a performance hit and I give some clean and simple solutions to solve it."]}),(0,o.jsx)("h2",{children:" Relay Commands"}),"The first timed I read about Relay Commands was in"," ",(0,o.jsx)("a",{href:"https://github.com/lbugnion/mvvmlight/blob/master/GalaSoft.MvvmLight/GalaSoft.MvvmLight%20(PCL)/Command/RelayCommand.cs",target:"_blank",children:"MVVM Light Toolkit"}),", since then I have seen several implementation examples like this",(0,o.jsxs)("a",{href:"https://www.technical-recipes.com/2016/using-relaycommand-icommand-to-handle-events-in-wpf-and-mvvm/",target:"_blank",children:[" ","one"]}),". So let us look to an usual Relay Command implementation in the next snippet:",(0,o.jsx)(d,{id:"6229f82df53f2856a49ed8b1595fbcf5"}),(0,o.jsx)("p",{children:"To create an instance (see the constructor) you only need to implement the action for the execute parameter(code to execute when a user clicks a button for example) and the action for the canExecute (state defining if the command can be executed) and that is the main advantage of it, simple and fast to implement."}),(0,o.jsx)("p",{children:"A good example is the print command:"}),(0,o.jsx)(d,{id:"0e78983201513a4590116712a6dc5af0"}),(0,o.jsxs)("p",{children:[" ","The print command command can be executed when the print service is online and just prints when invoked, simple as that, no need to explicitly raise the CanExecuteChanged event(will explain later why) to notify the UI to refresh / invalidate the current state of the inputs associated and therefore no need to think or implement the logic that can change the CanExecute state. In many cases this is an advantage because you can quickly implement the command. If command depends on third party services or data outside of our domain, that we do not own. Probably that third party service is not able to notify the state changed, so we need to continuously querying it, in this case the relay command fits well."]}),(0,o.jsx)("p",{children:(0,o.jsx)("strong",{children:"Why don\u2019t we need to call explicitly the CanExecuteChanged EventHandler?"})}),(0,o.jsx)("p",{children:"Looking to the following snippet of the Relay Command:"}),(0,o.jsx)(d,{id:"ca4f05673c26800d9c595b9fae40b106"}),(0,o.jsx)("p",{children:"Whenever the CanExecuteChanged is subscribed in fact it\u2019s subscribing the CommandManager.RequerySuggested, and this is the root cause of the performance issue that we may face:"}),(0,o.jsxs)("figure",{className:"text-end",children:[(0,o.jsx)("blockquote",{className:"blockquote",children:(0,o.jsxs)("p",{children:["Occurs when the"," ",(0,o.jsxs)("a",{href:"https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.commandmanager?view=netframework-4.8",target:"_blank",children:[" ","CommandManager"," "]})," ","detects conditions that might change the ability of a command to execute"]})}),(0,o.jsxs)("figcaption",{className:"blockquote-footer",children:["Microsoft documentation"," ",(0,o.jsx)("cite",{title:"Source Title",children:"CommandManager Class"})]})]}),(0,o.jsxs)("p",{children:["It\u2019s quite difficult to have an overview when this event is raised, because its trigger outside the CommandManager boundaries, you can dig the dotnet/WPF"," ",(0,o.jsxs)("a",{target:"_blank",href:"https://github.com/dotnet/wpf",children:[" ","repository"," "]}),". If you add a break point to the CanExecute method you will see this is called very very very often. A mouse move is sufficient to trigger this event!"]}),(0,o.jsx)("h2",{children:"Commands that can always be executed"}),(0,o.jsx)("p",{children:"Look to your commands and do not get surprised if a considerable part of then returns always true on the CanExecute method. An easy solution is to implement a command that simple returns true and completely avoid the Relay Command:"}),(0,o.jsx)(d,{id:"7f824b8a18445405024e8904cfb42655"}),(0,o.jsx)("p",{children:"With this change you easily save a lot of CPU usage."}),(0,o.jsx)("h2",{children:"Action or Delegate Commands"}),(0,o.jsx)("p",{children:"To remove the dependency to CommandManager.RequerySuggested, we need to code the rules that can change the CanExecute state. To do that we replace the Relay Command for a very similar Action Command:"}),(0,o.jsx)(d,{id:"50a417af8354992895de12d91f756fb3"}),(0,o.jsx)("p",{children:"The main difference is that there is not subscription to CommandManager.RequerySuggested. The previous PrintCommand example needs to be change to:"}),(0,o.jsx)(d,{id:"a1a885df1bce1b6017208b469a00a7b5"}),(0,o.jsx)("p",{children:"When IsOnlineChanged is raised, in PrintService, we need to explicitly call the RaiseCanExecuteChanged, in order to notify the UI to refresh according to the new state of the command. This small change may reduce the number of calls to CanExecute method to only one call as long asthe PrintService state does not change and this is much more optimized comparing to the Relay Command."}),(0,o.jsx)("h2",{children:"Avoid logic inside CanExecute"}),(0,o.jsx)("p",{children:"Another source of performance issues is that we tend to compute the CanExecute state inside the method itself. If this computation is expensive, and called multiple times, although the state did not change (the command can be attached to multiple inputs), it will have a performance hit. To resolve this issue we just need to compute it to a local variable and then return always the local variable value:"}),(0,o.jsx)(d,{id:"cbfb8192e9aced3ace6311da41e6e5f2"}),(0,o.jsx)("h2",{children:"Conclusion"}),(0,o.jsx)("p",{children:"If you are developing a application and not a POC avoid the usage of Relay Commands or similar, this will save you for sure a lot of rework. Unless it\u2019s used in very specif situations: short living view models or has dependencies on data that needs to be queried continuously."}),(0,o.jsx)("p",{children:"In my next post I will show how can we improve this implementation using Reactive Extensions, so keep in touch."}),(0,o.jsx)("p",{children:"See you soon."}),(0,o.jsxs)("figure",{className:"text-center",children:[(0,o.jsx)("img",{src:h,alt:"Keep it simple. Keep it clean."}),(0,o.jsx)("figcaption",{className:"figure-caption",children:"Keep it simple. Keep it clean."})]})]}),(0,o.jsx)(r.default,{category:"C#",date:"Apr 14, 2020",summary:"Multiple Relay Commands instances can become a source of serious CPU usage for long living View Models in a WPF application using MVVM pattern."})]})})})]})}}}]);
//# sourceMappingURL=138.b2b6c43e.chunk.js.map